# 图论

图论问题不要被吓到

二分与图论配合，判断是否用这条边，与01动态规划结合，变成边权

##失误

1.自己到自己的距离为0  d[i]\[i]=0

2.建新图时每个点必须时唯一的（题目给定坐标会有重点），如果是二分图，每个集合里的点是唯一的

3.图论预处理很重要



## 树学

1.树上任意两点间路径是唯一的

2.可以选定父亲节点来封住他的方向，让搜索方向固定

3.从一个点出发遍历所有结点并最后回到原来的点，则树上所有边都要访问两次
4.树上任意一点的最远点一定是树的直径的端点

## 最短路	

最短路自带贪心

### 汽车加油问题   

遍历每次只加一次   并且要确定上界

~~~
int bfs() {
	for(int i=1;i<=n;i++){
		for(int j=0;j<=lim;j++) d[i][j]=0x3f3f3f3f;
	}
	priority_queue<node2>q;
	q.push({ 0,start,0 });
	d[start][0] = 0;
	while (!q.empty()) {
		auto now = q.top();
		q.pop();
		int x = now.x;
		int c = now.c;
		int nw = now.nw;
		if (d[x][nw] != c) continue;
		if (x == ed)  return d[x][nw];
		if (nw+1<=lim&&c + a[x]  < d[x][nw+1]) 
		q.push({ c + a[x] ,x,nw+1 }), d[x][nw+1] = c + a[x] ;
		for (int i = head[x]; i; i = e[i].nxt) {
			int to = e[i].to;
			int w = e[i].w;
			if (nw - w >= 0) {
				if (d[to][nw - w] > c) q.push({ c,to,nw - w }), d[to][nw - w] = c;
			}
		}
	}
	return -1;
}
~~~



### 堆+dij：

边多不能用dij

不可以有负边权  复杂度  nlogn

~~~c++
int bfs(){
	priority_queue<pii>q;   //从大到小
	q.push({0,1});
	memset(d,0x3f,sizeof d);
	d[1]=0;
	while(!q.empty()){
		pii now=q.top();
		q.pop();
		int x=now.second;
		int c=-now.first;  //一般是负数  因为优先队列是从大到小
		if(x==n*k+n)return c;
		for(int i=head[x];i;i=edge[i].nxt){
			int to=edge[i].to;
			int w=edge[i].w;
			int tmp=max(d[x],w);
			if(d[to]>tmp){
				d[to]=tmp;
				q.push({-d[to],to});
			}
		}
	}
	return -1;
}
~~~



### spfa:

可以有负边权，queue+vis[],vis[x]在队内为1，不在队内为0，并且能更新就更新

~~~c++
void bfs(){
	memset(d,-0x3f,sizeof d);  //负无穷
	queue<int>q;
	q.push(1);
	d[1]=0;
	while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=0;        //不在队内为0
		for(int i=head[now];i;i=edge[i].nxt){
			int to=edge[i].to;
			int w=edge[i].w;
			if(d[to]<d[now]+w){
			 d[to]=d[now]+w;
			 if(!vis[to])q.push(to),vis[to]=1;  //能更新就更新
		  }
	  }
	}
}
~~~

### 01双端队列：

边权为0放队头，边权为1是放队尾，queue+vis[]，如果vis[]==1就被扩展过就跳过

```c++
deque<int>q;
q.push_front(1);
d[1] = 0;
while (!q.empty()) {
	int x = q.front();
	q.pop_front();
	if (vis[x])continue;   //已经以这个点扩展过了就跳过
	else vis[x] = 1;
	for (int i = head[x]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		int w = edge[i].w > mid;
		if (!vis[to] && d[to] > d[x] + w) {  
			d[to] = d[x] + w;
			if (w) q.push_back(to);
			else q.push_front(to);
		}
	}
}
```
###floryd：

时间的叠加，将多条路径转化为一条路径，拆点使得只能走一次

 A^k的第i行第j列的数字含义是从i走到j经过k步的路径方案数,边权必须为1 

#### 传递闭包：

通过传递性推导出尽量多的元素之间的关系的问题

```c++
for(int k=1;k<=n;k++)
 for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++) dp[i][j]|=dp[i][k]&dp[k][j];
```

### 分层图

每一层都代表不同的状态    一般还要特判什么都没干

~~~c++
void add2(int x,int y){
		//同层之间建立边
		add(x,y,0);
		add(x+n,y+n,0);
		add(x+2*n,y+2*n,0);
		//不同层之间建立边
		add(x,y+n,-c[x]);
		add(x+n,y+2*n,c[x]);
}
~~~

可以用来匹配，减少匹配的复杂度，将数据分成两份，在建一个中转点，建图 

~~~c++
for(int i=1;i<=n;i++){
	  cin>>a[i];
	 for(ll j=a[i];j;j-=lowbit(j)){
		ll x=lowbit(j);
		int to=mp[x];
		add(i,to+n+1,x),add(to+n+1,i,0);
	  }
  }
~~~

~~~c++
using namespace std;
const int maxn=3e6+1e5+10;
int n,k,a,b,c;
int head[maxn],mm,d[maxn];
struct Edge{
	int to,nxt,w;
}edge[maxn<<1];
int ck(int x,int y,int z){     //三维变一维
	return ((x-1)*n+y)+(n*n)*z;
}
void add(int x,int y,int w){
	edge[++mm]={y,head[x],w};
	head[x]=mm;
}
void dij(int f){
	priority_queue<pii>q;
	q.push({0,f});
	fill(d,d+maxn,0x3f3f3f3f);
	d[f]=0;
	while(!q.empty()){
		auto now=q.top();
		q.pop();
		int u=now.se;
		for(int i=head[u];i;i=edge[i].nxt){
			int to=edge[i].to;
			int w=edge[i].w;
			if(d[to]>d[u]+w){
				d[to]=d[u]+w;
				q.push({-d[to],to});
			}
		}
	}
}
int main(){
	cin>>n>>k>>a>>b>>c;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++){
		int x;
		cin>>x;
		if(x){
		 for(int p=1;p<=k;p++){
		  if(i-1>=1) add(ck(i-1,j,p),ck(i,j,k),a);
		  if(j-1>=1) add(ck(i,j-1,p),ck(i,j,k),a);
		  if(i+1<=n) add(ck(i+1,j,p),ck(i,j,k),a+b);
		  if(j+1<=n) add(ck(i,j+1,p),ck(i,j,k),a+b);
		 }
		}
		else{
			for(int p=1;p<=k;p++){
		  if(i-1>=1) add(ck(i-1,j,p),ck(i,j,p-1),0);
		  if(j-1>=1) add(ck(i,j-1,p),ck(i,j,p-1),0);
		  if(i+1<=n) add(ck(i+1,j,p),ck(i,j,p-1),b);
		  if(j+1<=n) add(ck(i,j+1,p),ck(i,j,p-1),b);
		  add(ck(i,j,p-1),ck(i,j,k),c+a);
		 }
		}
	}
	dij(ck(1,1,k));
	int ans=0x3f3f3f3f;
	for(int i=0;i<=k;i++){
	  ans=min(d[ck(n,n,i)],ans);
	}
	cout<<ans<<'\n';
}
~~~



## 最小生成树

最小生成树的任意子树都是最小生成树

###kru算法：

**每次连边其实是两个不相连连通块的相连**

边排序+并查集更新连通块

排序后每次找边权最小的点，如果点的连通块不相同，则合并在一起，总共要合并n-1次。 0（mlogm）

~~~c++
sort(edge+1,edge+n); //排序
ll ans=0;
for(int i=1;i<n;i++){
    int x=edge[i].x;
    int y=edge[i].y;
    int w=edge[i].w;
    int a=find(x),b=find(y);
    if(a!=b){  //不在同一个块就合并
    fa[a]=b;
    ans+=1ll*(w+1)*(sz[a]*sz[b]-1);
    sz[b]+=sz[a];
       }
}
~~~

### prim算法：

适合**边多**，复杂度为n^2

~~~c++
void prim(){
	memset(d,0x3f,sizeof d);
	d[1]=0;
	for(int _=1;_<=n;_++){      //循环n次
		int u=0,mx=0x3f3f3f3f;
		for(int i=1;i<=n;i++){
			if(!vis[i]&&mx>d[i]) mx=d[i],u=i;   //找出一个最小每个遍历过的点
		}
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].nxt){
			int to=edge[i].to;
			int w=edge[i].w;
			if(!vis[to]){     //只能更新没有找到的点
			if(d[to]>d[u]+w) d[to]=d[u]+w;
	   }
  }
 }
}
~~~

##最小树形图

处理有向边的最小生成树

若有向图中不存在有向环，说明该图就是最小树形图

poj 3164

~~~c++
//根为1
const int maxn = 110;
const int maxm = 10010;
struct Edge {
	int from, to;
	double w;
}edge[maxm];
struct node {
	double x, y;
};
node p[maxn];
double dis(node a, node b) {
	double x = a.x - b.x;
	double y = a.y - b.y;
	return sqrt(x * x + y * y);
}
int pre[maxn], vis[maxn], flag[maxn]; //flag标记缩点，标记为true
double in[maxn], sum;
double zhuliu(int root,int n, int m) {
	sum = 0;    //存放最小树形图
	while (1) {
		//求最短弧集合
		for (int i = 1; i <= n; i++) {
			in[i] = INT_MAX;
		}
		for (int i = 1; i <= m; i++) {
			int from = edge[i].from;
			int to = edge[i].to;
			if (edge[i].w < in[to] && from != to) {
				pre[to] = from;
				in[to] = edge[i].w;  //记录权值最小的边
			}
		}
		for (int i = 1; i <= n; i++) {  //如果存在出root以外的孤立点，则不存在最小树形图
			if (i == root) continue;
			if (in[i] == INT_MAX) return -1;
		}
		int cc = 0; //新图编号
		memset(flag, 0, sizeof flag);
		memset(vis, 0, sizeof vis);
		in[root] = 0;  //删去root的入边
		for (int i = 1; i <= n; i++) {  //找环，标记每个环
			sum += in[i];
			int to = i;
			//每个点寻找其前序点，要么最终寻找至根部,要么找到一个环
			while (vis[to] != i && !flag[to] && to != root) {
				vis[to] = i;
				to = pre[to];
			}
			if (to != root && !flag[to]) {  //新图重新编号
				flag[to] = ++cc;   //从1开始计算
				for (int j = pre[to]; j != to; j = pre[j]) {
					flag[j] = cc;
			}
				}
		}
		if (!cc) break;  //无环 退出
		for (int i = 1; i <= n; i++) {
			if (!flag[i]) 
				flag[i] = ++cc;
		}
		for (int i = 1; i <= m; i++) {
			int to = edge[i].to;
			int from = edge[i].from;
			edge[i].from = flag[from];
			edge[i].to = flag[to];
			if (flag[from]!= flag[to]) 
				edge[i].w -= in[to];
		}
		n = cc;
		root = flag[root];
	}
	return sum;
}	
int main() {
	int x, y, n, m;
	while (~scanf("%d%d", &n, &m)) {
		int id = 0;
		for (int i = 1; i <= n; i++) {
			scanf("%lf%lf", &p[i].x, &p[i].y);
		}
		for (int i = 1; i <= m; i++) {
			scanf("%d%d", &x, &y);
			if (x == y) continue;
			edge[++id].from = x;
			edge[id].to = y;
			edge[id].w = dis(p[x], p[y]);
		}
		double ans = zhuliu(1, n,id);
		if (ans == -1) printf("poor snoopy\n");
		else printf("%.2lf\n", ans);
	}
}
~~~





## 树的直径

### dfs两次求出路径

要dfs两次来求  可以标记  标记点的就是d[to]=u 标记边的话就是d[to]=i ; i是边    

~~~c++
 void dfs(int u){    dfs找路径
	vis[u] = 1;
	for (int i = head[u]; i; i = edge[i].nxt) {
		int v = edge[i].to, w = edge[i].w;
		if (vis[v]) continue;
		d[v] = d[u] + w;
		if (d[v] > d[e]) {
			e = v;
		}
		fa[v] = i;
		dfs(v);
	}
	vis[u] = 0;
}
____________________________________
  e=1;
  dfs(e);
  memset(d,0,sizeof d);
  memset(vis,0,sizeof vis);
  memset(fa,0,sizeof fa);
  dfs(e);
~~~

用while来回溯赋值边权

~~~c++
	while(fa[e]){         回溯赋值边权  e是最长点 方便回溯
		edge[fa[e]].w=edge[fa[e]^1].w=-1;   //mm=1开始  1 2为相反的边
		e=edge[fa[e]^1].to;
	}
~~~

###dp求最长路径

dp难回溯

~~~c++
void dp(int u){      dp找最长路径  但是dp不好回溯 也不知道标记谁是最长路径
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		int w=edge[i].w;
		if(vis[to]) continue;
		dp(to);
		res=max(res,d[to]+d[u]+w);
		d[u]=max(d[to]+w,d[u]);
	}
}

~~~



## 负环/正环

spfa算法求负环

求负环的常用方法  推荐第二种 是0（n）
1.统计每个点的入队的次数，如果每个点入队n次，代表更新了n次，说明边的数量大于等于n，则说明存在负环；
2.统计当前每个点的最短路中所包含的边数，如果某点的最短路包含的边数大于等于n，则也说明存在环

**注意** 一定要有一个超级源点能遍历所有点或者一开始所有点就入队

需要数组 cnt[] 入队次数   vis[]是否在队内 

~~~c++
//cnt[] 入队次数   vis[]是否在队内 
bool check(double mid){
	 memset(cnt,0,sizeof cnt);
	 memset(vis,1,sizeof vis);
	 int k=v.size();
	 int count=0;
	 queue<int>q;
	 for(auto i:v) q.push(i);
	 while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=0;
		for(int i=head[now];i;i=edge[i].nxt){
			int to=edge[i].to;
			double w=edge[i].w-mid;
			if(d[to]<d[now]+w){
				d[to]=d[now]+w;
				cnt[to]=cnt[now]+1;
				if(++count>4*k) return 1;  //特判 入队超过4*n次就是环
				if(cnt[to]>k) return 1;
				if(!vis[to]){
					vis[to]=1;
					q.push(to);
				}
		 }
	 }
 }
 return 0;
}
~~~



## 差分约束

不等式求解

求最大值 等价于求所有上界的最小值 就是求最短路  就是小于等于号 不存在正环

求最小值 等价于求所有下界的最大值 就是求最长路  就是大于等于号 不存在负环  

+-+

x>=y+1  add(x,y,1)  大于号 最长路

y<=x-1  add(y,x,-1)   小于号 最短路

步骤 【1】先将每个不等式xi<=xj+c 转化为一条从xj走到xi 长度为c的一条边 c为常数
         【2】找一个超级源点（虚拟），使得该源点一定可以遍历到所有边  也可以将所有数赋值为最值 全部入队
         【3】求单源最短路

一般与前缀和结合  解决不等式问题

**判是否有环要全部入队，判关系只要一个入队就行了**

如果是无穷 代表这个点不能被其他点更新

~~~c++
int bfs(int c){   //c代表求正/负环 还是求单源最短路  
	queue<int>q;
	memset(d,0x3f,sizeof d);
	memset(cnt,0,sizeof cnt);
	memset(vis,0,sizeof vis);
	 for(int i=1;i<=c;i++) q.push(i),vis[i]=1,d[i]=0; //求环全部入队  求单源最短路1个入队
	 int count=0;
	 while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=0;
		for(int i=head[now];i;i=edge[i].nxt){
			int to=edge[i].to;
			int w=edge[i].w;
			if(d[to]>d[now]+w){
				d[to]=d[now]+w;
				cnt[to]=cnt[now]+1;
				if(cnt[to]>n) return 0;          //大于n 存在环 不符合
				if(!vis[to]) vis[to]=1,q.push(to);
			}
		}
	}
	return 1;
}
~~~



## 最近公共祖先

模板：

###倍增法

~~~c++
const int maxn=5e5+100;
int fa[maxn][21];
int dep[maxn];
struct Edge{
	int to,nxt;
}edge[maxn<<1];
int head[maxn],mm;
void add(int x,int y){
  edge[++mm]={y,head[x]};
	head[x]=mm;
}
int n,m,root;
void dfs(int u,int from){
	dep[u]=dep[from]+1;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to==from) continue;
		fa[to][0]=u;
		for(int i=1;i<=20;i++)
		 fa[to][i]=fa[fa[to][i-1]][i-1];
		dfs(to,u); //更新完在搜
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	//跳到同一层
	for(int i=20;i>=0;i--){
		if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	}
	//在一起了 就直接退出
	if(x==y) return x;
	//同时跳 跳到最近公共祖先的下一层
	for(int i=20;i>=0;i--){
  	if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}

int main(){
	cin>>n>>m>>root;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	//预处理哨兵  特别注意
	memset(dep,0x3f,sizeof dep);
	dep[0]=0; //根的父亲节点
	dep[root]=1;
	//预处理dep和fa数组
	dfs(root,0);
	while(m--){
		int x,y;
		cin>>x>>y;
		cout<<lca(x,y)<<'\n';
	}
}
~~~

###tarjan法离线求

~~~c++
typedef long long ll;
typedef pair<ll,int>pii;
const int maxn=1e5+10;
int head[maxn],mm,n;
struct Edge{
	int to,nxt;
}edge[maxn<<1];
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
int dis[maxn],fa[maxn],res[maxn],st[maxn];
vector<pii>v[maxn]; //记录操作和编号
void init(){
	for(int i=1;i<=n;i++) fa[i]=i;
}
int find(int x){ return x==fa[x]?x:fa[x]=find(fa[x]);}
void dfs(int u,int from){
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to!=from){
			dis[to]=dis[u]+1;
			dfs(to,u);
		}
	}
}
void tarjan(int u){
	st[u]=1;//正在查询
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!st[to]){   //没有遍历过
      tarjan(to);
      fa[to]=u; //to的最近公共祖先是u
    }
	}
	for(auto i:v[u]){
		int y=i.first,id=i.second;
		if(st[y]==2){  //已经遍历过了
			int lca=find(y);
      res[id]=dis[u]+dis[y]-2*dis[lca];
    }
  }
  st[u]=2; //遍历完了
}
int main(){
	cin>>n;
	init();
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	int q;
	cin>>q;
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		v[x].pb({y,i});  //插入查询点
		v[y].pb({x,i});
	}
	dfs(1,-1);
	tarjan(1);
	for(int i=1;i<=q;i++) cout<<res[i]<<'\n';
}
~~~



## 树上差分

模板

~~~c++
const int maxn=1e5+10;
int head[maxn],mm=1,cnt[maxn],t;
int n,m;
struct Edge{
	int to,nxt;
}edge[maxn<<1];
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
int d[maxn],f[maxn][110];
void bfs()
{
	queue<int> q;
	t=(int)(log(n)/log(2))+1;
	q.push(1);  //根节点入队
	d[1]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=edge[i].nxt)
		{
			int y=edge[i].to;
			if(d[y])
			continue;
			d[y]=d[x]+1;
			f[y][0]=x;
			for(int j=1;j<=t;++j)
			f[y][j]=f[f[y][j-1]][j-1];
			q.push(y);
		}
	}
}
int lca(int x,int y)
{
	if(d[x]>d[y])
	swap(x,y);
	for(int i=t;i>=0;--i)
	{
		if(d[f[y][i]]>=d[x])
		y=f[y][i];
	}
	if(x==y)
	return x;
	for(int i=t;i>=0;--i)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
void dfs(int u,int fa){
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to==fa) continue;
		dfs(to,u);
		cnt[u]+=cnt[to];
	}
}
~~~



### 树上的边差分 

~~~c++
cnt[x]+=k;
cnt[y]+=k;
cnt[lca(x,y)]-=2*k;  //注意是两倍
~~~

### 树上的点差分

~~~c++
int LCA=lca(x,y);
sum[x]+=k;
sum[y]+=k;
sum[LCA]-=k;
sum[f[LCA][0]]-=k;
~~~



## 有向图的强连通

强连通分量：对于分量中任意两点u,v，必然存在从u走到v，且从v走到u

将任意一个有向有环图缩点（将连通分量缩成一个点）转为<u>有向无环图</u>（拓扑图）

一般是看度数（出度，入度） 找出结论

栈中的倒序就是topu序，可以用来dp更新

特判  如果只有一个强连通 那么这个块入度为0 出度也为0  

~~~c++
这题就是求出度为0的点有多少个
const int N=10010,M=50010;
int n,m,head[N],mm;
struct Edge{
	int to,nxt;
}edge[M];
int dfn[N],low[N],tim;//时间戳  时间戳变量
int stk[N],ss;   //栈
bool vis[N]; //判断是否在栈中
int id[N],cnt,size[N];//每个强连通的编号，当前有多少强连通分量，强连通分量中点的数量
int ou[N]; //出度
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
void tarjan(int u){
	dfn[u]=low[u]=++tim;  //记录时间戳
	stk[++ss]=u,vis[u]=1;     //把当前的点放入栈中 //栈中是当前每个没有搜完的强连通分量的所有点
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!dfn[to]){    //没有遍历过就遍历
			tarjan(to);
			low[u]=min(low[u],low[to]); //记录最小时间戳
		}
		else if(vis[to]) low[u]=min(low[u],dfn[to]);  //当前点已经被遍历了 用编号更新low[u]
	}
	if(dfn[u]==low[u]){  //然后当前这个点能遍历到的就是自己了  
		int y;
		++cnt;
		do{
			y=stk[ss--];
			vis[y]=0;
			id[y]=cnt;
			size[cnt]++;
	  }while(y!=u);
	}
}
int main(){
	cin>>n>>m;
	while(m--){
		int a,b;
		cin>>a>>b;
		add(a,b);
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]) tarjan(i); //当前的点没有被遍历过的话  我们就遍历下
  }
  for(int i=1;i<=n;i++){
	for(int j=head[i];j;j=edge[j].nxt){
		int to=edge[j].to;
			int a=id[i],b=id[to];
			if(a!=b){ //a b属于不同连通分量中
				ou[a]++;
			}
	 }
  }
	int z=0,sum=0;  //sum是出度为0的点的数量之和
	for(int i=1;i<=cnt;i++){  //遍历
		if(!ou[i]){
			z++;
			sum+=size[i];
			if(z>1){      //只要有多于一个点的出度为0 那么就不会有牛被所以牛欢迎
				sum=0;
				break;
			}
		}
	}
	cout<<sum<<'\n';
}

~~~

 建新图+dp

1.cnt里面的<u>逆序</u>就是拓扑序 

2.建新图不用改mm  要改head2[]

~~~c++
const int maxn=1e5+10;
int n,m,mod;
int head[maxn],mm,head2[maxn];
int dfn[maxn],low[maxn],tim;
int vis[maxn],stk[maxn],ss,cnt,id[maxn],size[maxn];
int mxk[maxn],num[maxn];
unordered_map<ll,bool>mp;
struct Edge{
	int to,nxt;
}edge[maxn*40];
void add(int head[],int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
void tarjan(int u){
	dfn[u]=low[u]=++tim;
	stk[++ss]=u;
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[u]=min(low[u],low[to]);
		}
		else if(vis[to]) low[u]=min(low[u],dfn[to]);
	}
	if(low[u]==dfn[u]){
		int y;
		cnt++;
		do{
			y=stk[ss--];
			id[y]=cnt;
			size[cnt]++;  //该节点的点数
			vis[y]=0;
		}while(y!=u);
	}
}
int main(){
	cin>>n>>m>>mod;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		add(head,x,y);
	}

	for(int i=1;i<=n;i++){
		if(!dfn[i]) tarjan(i);
	}
    //建新图
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=edge[j].nxt){
			int to=edge[j].to;
			int x=id[i],y=id[to];
			ll d=1ll*x*100000+y;
			if(x!=y&&!mp[d]){
				add(head2,x,y);    //建图
				mp[d]=1;
			}
		}
	}
    //dp
	for(int i=cnt;i>=1;i--){
		if(!mxk[i])mxk[i]=size[i],num[i]=1;
		for(int j=head2[i];j;j=edge[j].nxt){
			int to=edge[j].to;
			if(mxk[to]<mxk[i]+size[to]){
				mxk[to]=mxk[i]+size[to];
				num[to]=num[i]%mod;
			}
			else if(mxk[to]==mxk[i]+size[to]){
				num[to]=(num[i]+num[to])%mod;
			}
		}
	}
	int ans1=0,ans2=0;
	for(int i=1;i<=cnt;i++){
		if(mxk[i]>ans1) ans1=mxk[i],ans2=num[i];
		else if(mxk[i]==ans1) ans2=(ans2+num[i])%mod;
	}
	cout<<ans1<<'\n'<<ans2%mod<<'\n';
}

~~~



## 无向图的强连通

桥： 删掉这条无向边 图就不连通

割点  在无向图中把点删除后 图就不连通了

1.边的双连通分量  e-dcc   极大的不包含桥的连通块  不含有桥  

2.点的双连通分量  v-dcc  极大的不包含割点的连通块

***有向图最少加多少条边让他变成强连通分量 max(q,p) 出度 入度为0取max**

***无向图的话加多少条边让他变成双连通分量就是 (cnt+1)/2 度为1的点  连线的话就是 i连i+(cnt+1)/2; 中间那个人点随便连**

~~~c++
//边的双连通分量 不含桥
//找桥：  dfn[x]<low[y]
const int maxn=5010;
int n,m;
int dfn[maxn],deg[maxn],low[maxn];
int stk[maxn],ss,vis[maxn];
int br[maxn]; //判断是否是桥
int head[maxn],mm=1,id[maxn],cnt,tim;
struct Edge{
	int to,nxt;
}edge[maxn<<2];
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
void tarjan(int u,int f){              //f是反向边的编号
	dfn[u]=low[u]=++tim;
	stk[++ss]=u,vis[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!dfn[to]){
			tarjan(to,i);
			low[u]=min(low[u],low[to]);  //更新
			if(dfn[u]<low[to]){  //如果下节点严格大于父亲节点 说明 to到不了u
		    br[i]=br[i^1]=1;   //正向边和反向边都是桥 给桥打标记
	  }
		}
		else if(i!=(f^1)){   //不是反向边 就更新low[u]
		 low[u]=min(low[u],dfn[to]);
	  }
	}
	if(dfn[u]==low[u]){      //缩点
		++cnt;
		int y;
		do{
			y=stk[ss--];
			id[y]=cnt;
	 }while(y!=u);
  }
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);add(y,x);
	}
	//枚举边
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i,-1);
	int ans=0;
	for(int i=1;i<=mm;i++){  //枚举每个边 
	if(br[i]){
			deg[id[edge[i].to]]++;         //如果是桥的话所在的地方度数++；一个桥代表一个度
                                           //因为是双向边 所以只加一个方向
		}
	}
	for(int i=1;i<=cnt;i++) if(deg[i]==1) ans++;
	if(cnt==0) cout<<0<<'\n';  //特判只要一个双连通分量
	else cout<<(ans+1)/2;
}
~~~

~~~c++
//割点 low[y]>dfn[x];
//1.如果不是根节点  那么x是割点 
//2.x是根节点  至少有两个子节点y才是割点
//这题是找割点个数
const int maxn=100010,M=300010;
int n,m;
int head[maxn],mm,ans;
int dfn[maxn],low[maxn],tim,root;
struct Edge{
	int to,nxt;
}edge[M];
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
void tarjan(int u){
	dfn[u]=low[u]=++tim;
	int cnt=0;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[u]=min(low[u],low[to]);
			if(low[to]>=dfn[u]){  //这个点不能跑到u这个点的上面
		    cnt++;   //有一个割点
	  }
   }
   else low[u]=min(low[u],dfn[to]);     //搜过了 更新low[u]
   }
	 if(u!=root&&cnt) cnt++;     //如果这个点不是根节点要加1
	 ans=max(ans,cnt);
}

int main(){
	while(cin>>n>>m,n||m){
		for(int i=1;i<=n;i++) head[i]=dfn[i]=low[i]=0;
		mm=tim=ans=0;
		int cnt=0;
		for(int i=1;i<=m;i++){
			int x,y;
			cin>>x>>y;
			x++,y++;
			add(x,y),add(y,x);
		}
		for(root=1;root<=n;root++){   
			if(!dfn[root]) cnt++,tarjan(root);
		}
		cout<<cnt+ans-1<<'\n';
	}
}
~~~



## 二分图

### 二分图染色

二分图染色 1.要判断图是非连通图还是连通图 连通图就是一次dfs  非连通图就是多次dfs

二分图可以尝试看成两个不同独立集

~~~c++
//这道题就是两个独立集取2^x+2^y
//注意要col[i]先赋值为-1  st取0或者1
const int maxn=3e5+10;
ll mod=998244353 ;
ll n,m,col[maxn],w[maxn],a,b;
vector<int>v[maxn];
bool ok;//判断是否存在二分图
void dfs(int now,int st){
	 col[now]=st;
	 if(st==1) a++;
	 else b++;
	 if(ok)return;
	 for(auto i:v[now]){
		if(col[i]==st){
		 ok=1;
		 return ;
	  }
	  if(col[i]!=-1) continue;
		dfs(i,st^1);
	}
}
int main(){
	w[0]=1;
	w[1]=2;
	w[2]=4;
	for(int i=3;i<=maxn-10;i++) w[i]=w[i-1]*2ll%mod;
	int t;cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++) v[i].clear(),col[i]=-1;
		for(int i=1;i<=m;i++){
			int x,y;
			cin>>x>>y;
			v[x].pb(y);
			v[y].pb(x);
		}
	ll res=1;
	int flag=0;
	for(int i=1;i<=n;i++){
		if(col[i]==-1){          //对每个连通块进行操作
			 a=b=0;
			 ok=0;
			 dfs(i,0);
			 if(ok){
				flag=1;
				break;
			 }
	   res=res*(w[a]+w[b])%mod;
	   }
   }
   if(!flag) cout<<res%mod<<'\n';
   else cout<<0<<'\n';
  }
}
~~~

看边权 每次只染to就行了

~~~c++
题意：//同一组内部边的权重最大值最小
二分+二分图染色  一般染色图都是多个连通图
//不符合边就拆开 放在两个不同集合里面  小于mid的不染色 大于mid的染色
const int maxn=1e5+10;
int n,m,mm,head[20010],col[maxn];
struct Edeg{
	int to,nxt,w;
}edge[maxn<<1];
void add(int x,int y,int w){
	edge[++mm]={y,head[x],w};
	head[x]=mm;
}

bool dfs(int u,int c,int mid){
	col[u]=c;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		int w=edge[i].w;
		if(w<=mid)  continue;//不染
	if(col[to]==c)return 0;
	if(col[to]!=-1) continue;    //避免重复输入
		if(!dfs(to,c^1,mid)) return 0;
	}
	return 1;
}
bool check(int mid){
	memset(col,-1,sizeof col);
	for(int i=1;i<=n;i++){
		if(col[i]==-1){       //对不同连通块操作
		 if(!dfs(i,0,mid)) return 0;
	  }
	}
	return 1;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		add(x,y,w);
		add(y,x,w);
	}
	int l=0,r=1e9;
	while(l<r){
		int mid=l+r>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<l<<'\n';
}
~~~

### 二分图最大匹配 0(nm)

看题目是否可以分成两个集合S和T，建边，建单向边或者是唯一点的双向边；

每次用一个集合的元素去匹配另一个集合，就是S和T一一对应

匹配的关键就是一个元素精确的对应另外一个元素

主要是腾，就是他必须让给下一位

1.如果是棋盘，i+j为偶数方块当黑点  i+j为奇数当白点  根据奇偶性不同来做

2.男女配丢 AB任务配对 

vis[]每次都要初始化 表明这个点在这次是否被匹配过  match[]表明这个点选了谁

**最大匹配数=最小点覆盖=总点数-最大独立集=总点数-最小路径覆盖**

**最小路径重复点覆盖：**求出其传递闭包，在传递闭包上做二分图匹配 ，就相当于最小路径覆盖

#### 最小点覆盖

  每个点集 每条边最少有一个点在这个点集里面 答案是最大匹配书

~~~c++
const int maxn=110;
int n,m,k,match[maxn];  //match 初始化为-1
bool vis[maxn];
vector<int>v[maxn];
bool dfs(int u){
	for(auto i:v[u]){
		if(vis[i]) continue;
		vis[i]=1;
		if(match[i]==-1||dfs(match[i])) {  //如果这没被选上或者可以换人
		match[i]=u;
		return 1;
	  }
	}
	return 0;
}
int main(){
 while(cin>>n,n){
 cin>>m>>k;
 for(int i=1;i<=max(n,m);i++) v[i].clear(),match[i]=-1;
 for(int i=1;i<=k;i++){
	 int x,y,z;
	 cin>>x>>y>>z;
	 if(y==0||z==0) continue;
	 v[y].pb(z);
 }
 int ans=0;
 for(int i=1;i<n;i++){
	memset(vis,0,sizeof vis);
	 if(dfs(i)) ans++;
 }
 cout<<ans<<'\n';
 }
}
~~~



#### 最大独立集

一个点集里面，点集中的各点没有关系  点的个数最多就是最大独立集

答案是总点数-最大独立集

~~~
//日字性走法 八个方向 分别是2,1,-2,-1 中选  不能同时选 （1，-1）  （2，-1） 要定x 来选y
//每次的奇偶性不同  因此可以用匈牙利算法来做
//棋盘要判断是否是二分图  才去考虑是否用匈牙利算法  每个点必须是奇偶性不同
注意 x+dx[i][0],y+dy[i][1] 
const int maxn=110;
int n,m,k;
pii match[maxn][maxn];
bool vis[maxn][maxn],g[maxn][maxn];
int dxy[8][2]={{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};
bool dfs(int x,int y){
	for(int i=0;i<8;i++){
		int dx=x+dxy[i][0],dy=y+dxy[i][1];
		if(dx<1||dy<1||dx>n||dy>m||vis[dx][dy]||g[dx][dy]) continue;
		vis[dx][dy]=1;
		pii p=match[dx][dy];
		if(p.fi==0||dfs(p.fi,p.se)){
			match[dx][dy]={x,y};
			return 1;
		}
	}
	return 0;
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x>>y;
		g[x][y]=1;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++){
		if((i+j)&1||g[i][j]) continue;
		memset(vis,0,sizeof vis);
		if(dfs(i,j)) ans++;
	 }
 cout<<n*m-k-ans<<'\n';
}
~~~



## 最小路径覆盖

有向无环图的最小路径覆盖

让很多条不相交的路径去覆盖所给的图，问最少要多少条。

~~~c++
//输出每个最小路径覆盖路径  把点拆成入点和出点进行二分图匹配
//用do while进行路径输出
const int maxn = 310;
int n, m, match[maxn];  //match 初始化为-1
bool vis[maxn];
vector<int>v[maxn];
bool dfs(int u) {
	for (auto i : v[u]) {
		if (vis[i]) continue;
		vis[i] = 1;
		if (!match[i] || dfs(match[i])) {  //如果这没被选上或者可以换人
			match[i] = u;
			match[u] = i;
			return 1;
		}
	}
	return 0;
}
vector<int>v2;
void p(int x)
{
	x += n; //为了统一操作，所以我们先加一次
	do
	{
		x = x - n;
		cout << x << ' ';
		vis[x] = 1;
		x = match[x];
	} while (x);
	cout << endl;
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		v[x].pb(y + n);
	}
	int ans = 0;
	memset(match, 0, sizeof match);
	for (int i = 1; i <= n; i++) {
		memset(vis, 0, sizeof vis);
		if (dfs(i)) ans++;
	}
	memset(vis, 0, sizeof vis);
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			p(i);
		}
	}
	cout << n - ans << '\n';
}
~~~

#### 最小路径重复点覆盖   

就是找出最少的路径  每条路径上的任意点都可以相互看到 这些路径经过全部点  单独的点不算

传递闭包来做最大匹配  答案是总点数-最大匹配

~~~
//二分图在做的时候 存的是有向边 就是只要左边到右边的边即可
//每条路径上的任意点都可以相互看到。那么我们可以求出这个图的最小路径重复点覆盖的条数cnt
int n,m;
bool g[210][210],vis[210];
int match[210];
bool dfs(int u){
	for(int i=1;i<=n;i++){
		if(vis[i]||!g[u][i]) continue;
		vis[i]=1;
		int p=match[i];
		if(p==0||dfs(p)){
			match[i]=u;
			return 1;
		}
	}
	return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		g[x][y]=1;
	}
	for(int k=1;k<=n;k++)
	 for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		 g[i][j]|=g[i][k]&&g[k][j];
	int res=0;
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof vis);
		if(dfs(i)) res++;
	}
	cout<<n-res<<'\n';
}
~~~

#### HK算法  

复杂度为sqrt(n)*e

~~~c++
const int maxn = 6010;
int vis[maxn];
int n, m,  mm, head[maxn];
struct node {
	ll x, y, w;
}p[6010];
struct Edge {
	int to, nxt;
}edge[maxn*1500];
void add(int x, int y) {
	edge[++mm] = { y,head[x] };
	head[x] = mm;
}
int dep[maxn], con[maxn];  //con要赋值-1 
bool bfs() {
	memset(dep, 0, sizeof dep);
	queue<int> q;
	for (int i = 1; i <= n; ++i) if (con[i] == -1) q.push(i);
	bool flag = false;
	while (q.size()) {
		int now = q.front();
		q.pop();
		for (int i = head[now]; i; i = edge[i].nxt) {
			int to = edge[i].to;
			if (!dep[to]) {
				dep[to] = dep[now] + 1;
				if (con[to] == -1) flag = true;
				else dep[con[to]] = dep[to] + 1, q.push(con[to]);
			}
		}
	}
	return flag;
}
bool dfs(int u) {
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (dep[to] != dep[u] + 1) continue;
		dep[to] = 0;
		if (con[to] == -1 || dfs(con[to])) {
			con[u] = to;
			con[to] = u;
			return true;
		}
	}
	return false;
}
int sol() {  //返回最大匹配数
	int ans = 0;
	while (bfs()) {
		for (int i = 1; i <= n; i++) if (con[i] == -1 && dfs(i)) ans++;
	}
	return ans;
}
~~~



## 欧拉路径和欧拉回路

#### 有向图 

(1)存在欧拉路径的充分必要条件:度数为奇数的点只能有0或2个.

(2)存在欧拉回路的充分必要条件:度数为奇数的点只能有0个

#### 无向图

(1)存在欧拉路径的充分必要条件: 要么所有点的入度均等于出度;要么除了两个点之外,其余所有点的出度等于入度,剩余的两个点:一个满足入度比出度多1(终点),一个满足出度比入度多1(起点);

(2)存在欧拉路径的充分必要条件:所有点的入度等于出度

## 拓扑排序   

关键字：**有向无环图**   

a>b b>c 且无矛盾 就是有向无环图

也可以用来判环

有时候可能是逆序输出 

~~~c++
vector<int>v; //存拓扑序
int in[maxn]; //入度
void toposort(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(in[i]==0)  q.push(i);
	}
	while(!q.empty()){
		int x=q.front();
		v.pb(x);
		q.pop();
		for(int i=head[x];i;i=edge[i].nxt){
			int to=edge[i].to;
			in[to]--;
			if(in[to]==0) q.push(to);
		}
	}
}
~~~

## 网络流

一.流网络（单向边）  有源点和汇点，就是 源点的水通过不同管道流向汇点

可行流  2个条件  可行流  1.容量限制  0<=f(u,v)<=c(u,v);    2.流量守恒  流入=流出

最大流就是最小可行流

如果残留网络没有可行流，原网络就是最大流

二.割  将图分为两部分S和T   S有源点   T有汇点

割的容量  S指向T的边的容量之和

最小割 容量的最小值（流过去）

最大流最小割定理
1.可行流f是最大流
2.可行流f的残留网络中不存在增广路
3.存在某个割[S，T]，|f|=c(S,T) //f是可行流的流量=c是割的容量



限制走的次数一般转化为网络流中边权的问题；

 拆点连容量为1的边表示只能取一次；容量为inf的边表示可以走的关系



1.最大权闭合子图

​       正权点和-最小割(最大流)

​       如果一个点被选择了则后继必须被选择，用最小割解决，考虑割边的含义

2.特判只跑一次 

3.最大流可以限制流量   最大费用可以选出题目需要的路

4.网络流流完后里面每个点的流量应该都为0

~~~
///最小割  -》费用为1的最大流
//最大流解释不了 用最小割 最小割解决最大权闭合子图问题
//枚举两个点当起点和终点
//选点的话考虑拆点，点自身建边来判断这个点是否被选 ck(i,j,k) i*n+j+k*n*n;
//最大权闭合图的点就是从起点开始广搜，权值为0的点不走，能走到的点就是被选中的点。dinic最后一次bfs的d数组正好可以用来判断这个条件。
//方案选择的话 看点的出点和入边   有源点到d 就是会变成0  反之就是1
//网络流做二分图匹配的话 把点拆为入边和出边 i和i+n之间不连边  s连i   i+n连t
//最小路径覆盖 递归输出
//点有两个或者多个状态 考虑拆点
//不同的点不同的状态  分状态考虑
//让一个点固定量  把这个点连接S或者T  流量就是这个点的值
~~~

##注意  mm一定要置一

##技巧 

拆点，拆边，利用残量网络，改变流量的意义等等



应用：

1.在单源单汇流量图中，最大流等于最小割

###dinic求最大流最小割  （1e4-1e5）

~~~c++
//d[i]不为0 肯定用过
dinic求最大流=最小割
mm要置1
    const int maxn=1e4+10;
int head[maxn],mm=1;
int n,m,s,t;
int nh[maxn],d[maxn];
struct Edge{
    int to,nxt,w;
}edge[100010<<1];
void add(int x,int y,int w){
    edge[++mm]={y,head[x],w};
    head[x]=mm;
    edge[++mm]={x,head[y],0}; //流回来的量
    head[y]=mm;
}
//求增广路径
bool bfs(){
    memset(d,-1,sizeof d);
    queue<int>q;
    q.push(s);
    d[s]=0;
    nh[s]=head[s];
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=edge[i].nxt){
            int to=edge[i].to;
            int w=edge[i].w;
            // 有残留网络 并且没有被遍历过
            if(d[to]==-1&&w){
                d[to]=d[now]+1;
                nh[to]=head[to];
                if(to==t) return 1;
                q.push(to);
            }
        }
    }
    return 0;
}
int find(int u,int sum){
    if(u==t) return sum;
    int res=0;
    for(int i=nh[u];i&&res<sum;i=edge[i].nxt){
        int to=edge[i].to;
        int w=edge[i].w;
        nh[u]=i;
        if(d[to]==d[u]+1&&w){
            int tmp=find(to,min(w,sum-res));
            if(tmp) res+=tmp,edge[i].w-=tmp,edge[i^1].w+=tmp;
            else d[to]=-1; //废点优化
        }
    }
    return res;
}

int dinic(){
    int res=0,flow;
    while(bfs()){
        while(flow=find(s,1e9)) res+=flow;
    }
    return res;
}
int main(){
	cin>>n>>m>>s>>t;
    mm=1;  //一定要置1
	for(int i=1;i<=m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		add(x,y,w);  //流过去流量为w   流回来的为0 
	}
	cout<<dinic()<<'\n';
}
~~~







<img src="C:\Users\13772\AppData\Roaming\Typora\typora-user-images\image-20200818201855112.png" style="zoom:50%;" />    



## 输出对应方案

正向如果满流的话 f=0  

~~~c++
//根据网络流的特征，我们可以发现如果某一道试题被归入了某一个类型，那么这道试题到这个类型的边就会跑上1的流量
//根据残留网络  如果正向边跑上了1的流量，正向边的容量即变为0，而反向边的容量即成为1
//找点直接找head[]，然后找他的出边  判断是否符合条件  然后输出
//w==1 被用过
//这个是逆序  正序 edge.   
//残留网络搞完后流量为1
for(int i=1;i<=k;i++){
	cout<<i<<':'<<' ';
    for(int j=head[i+n];j;j=edge[j].nxt){
	 	int to=edge[j].to;
	 	if(to!=t&&edge[j].w==1) cout<<to<<' ';
	}
   cout<<'\n';
}
~~~



###网络流求二分图最大匹配  

0(sqrt(n)*m)

//二分图匹配  要拆点  但是i和i+n不用建边  

	s=n*2+1;t=s+1;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		add(x,y+n,1);
	}
	for(int i=1;i<=n;i++){
		add(s,i,1);
		add(i+n,t,1);
	}
## 费用流

每条边加上单位费用w(x,y)，注意是单位费用

最大费用跑最长路  最小费用跑最短路  

~~~c++
//最大费用跑最长路
//每跑一次edge[i].f会变  如果要跑一次最大一次最小的话  要有edge[i],edge2[i]
//mm要赋值为1
const int maxn = 100010;
const int inf = 0x3f3f3f3f;
int n, k;
int s, t, maxflow;
int head[maxn], mm=1;
int ans;
int d[maxn], incf[maxn], pre[maxn], vis[maxn];  //incf[] 剩余流量
struct Edge {
	int to, nxt, w, f;
}edge[maxn<<1];
//点的映射
int ck(int i, int j, int k) {
	return (i - 1) * n + j + k * n * n;
}
void add(int x, int y, int w, int f) {
	edge[++mm] = { y,head[x],w,f };
	head[x] = mm;
	edge[++mm] = { x,head[y],-w,0 };
	head[y] = mm;
}
bool spfa() {
	queue<int>q;
	memset(d, 0xcf, sizeof d);
	memset(vis, 0, sizeof vis);
	q.push(s), d[s] = 0, vis[s] = 1;  //最大费用求最长路
	incf[s] = 1 << 30;
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		vis[now] = 0;
		for (int i = head[now]; i; i = edge[i].nxt) {
			int to = edge[i].to;
			int w = edge[i].w;
			int f = edge[i].f;
			if (f > 0 && d[to] < d[now] + w) {
				d[to] = d[now] + w;
				incf[to] = min(incf[now], f);
				pre[to] = i;
				if (!vis[to]) q.push(to), vis[to] = 1;
			}
		}
	}
	if (d[t] ==0xcfcfcfcf) return 0;  //汇点不可到达
	return 1;
}
void update() {
	int x = t;
	while (x != s) {
		int i = pre[x];
		edge[i].f -= incf[t];
		edge[i ^ 1].f += incf[t];
		x = edge[i ^ 1].to;
	}
	maxflow += incf[t];
	ans += d[t] * incf[t];
}
int main() {
	cin >> n >> k;
	s = 1; t = 2 * n * n;//出点和汇点
	mm = 1;
	for(int i=1;i<=n;i++)
		for (int j = 1; j <= n; j++) {
			int c;
			cin >> c;
			add(ck(i, j, 0), ck(i, j, 1), c, 1); //流量为1
			add(ck(i, j, 0), ck(i, j, 1), 0, k - 1);//流量为k-1
			if (i < n) add(ck(i, j, 1), ck(i + 1, j, 0), 0, k );
			if (j < n) add(ck(i, j, 1), ck(i, j + 1, 0), 0, k );
		}
	while (spfa()) update();
	cout << ans << '\n';
}
~~~

## 树上启发式合并

dsu on tree 是一种处理树上不带修改的离线子树问题的算法，时间复杂度为 O(nlogn)  

核心思想：把小的往大的合并

1.分出大小，预处理出轻儿子和重儿子

2.先处理轻儿子和其子树的答案，算好答案后撤销贡献(因为不能开二维)

3.处理重儿子的答案，不撤销贡献

4.暴力统计所有轻儿子及其子树以及u节点本身的贡献，在与上步算出来的重儿子的贡献合并，得出答案



子树信息的储存可能是 普通数组  可能是map  也可能是树状数组这种既支持存储有支持删除的容器

树的最近公共祖先lca问题，考虑枚举每个数当lca

~~~c++
模板
#include<bits/stdc++.h>
#define fi first
#define se second
#define pb push_back

using namespace std;
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<double, double>pdd;
const int maxn = 5e5+10;
int head[maxn],sum[maxn][26],mm;
int siz[maxn],dep[maxn],vis[maxn],son[maxn],ans[maxn];
char s[maxn];
struct Edge{
	int to,nxt;
}edge[maxn<<1];
struct node{ int id,k;};
vector<node>v[maxn];
int cnt[maxn][26];
void add(int x,int y){
	edge[++mm]={y,head[x]};
	head[x]=mm;
}
void dfs(int u,int from){
	siz[u]=1;
	dep[u]=dep[from]+1;
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to==from) continue;
		 dfs(to,u);
	   siz[u]+=siz[to];
  	 if(!son[u]||siz[son[u]]<siz[to])  son[u]=to;
	}
}
void calc(int u,int from,int val){
	/*
   自己操作
   记录子链的贡献
   cnt[]+=val
	*/
	cnt[dep[u]][s[u]-'a']+=val;//记录贡献,如果有后效性就要分开
    //递归子树
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(vis[to]||to==from) continue;
		calc(to,u,val);
	}
}
bool check(int sum[]){
	 int res=0;
	 for(int i=0;i<26;i++){
		 if(sum[i]&1) res++;
		 if(res>1) return 0;
	}
	return 1;
}
void dfs2(int u,int from,int keep){
	for(int i=head[u];i;i=edge[i].nxt){
		int to=edge[i].to;
		if(to==from||to==son[u]) continue;
		dfs2(to,u,0);
	}
	if(son[u]) dfs2(son[u],u,1),vis[son[u]]=1;
    //处理子树信息
	calc(u,from,1);    //计算子树贡献
	vis[son[u]]=0;
  //统计最终答案 自己操作
  for(auto i:v[u]) ans[i.id]=check(cnt[i.k]);
	if(!keep) calc(u,from,-1);  //撤销
}

signed main(){
	ios::sync_with_stdio(false); std::cin.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x;
		cin>>x;
		add(x,i+1);
	}
	cin>>s+1;
    //离线操作
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		v[x].pb({i,y});
	}
	dfs(1,0);
	dfs2(1,0,0);
	for(int i=1;i<=m;i++) cout<<(ans[i]?"Yes":"No")<<'\n';
}


​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

变形 lca  先统计一棵子树答案在记录贡献
void add(int x, int y) {
	edge[++mm] = { y,head[x] };
	head[x] = mm;
}
void dfs(int u, int from) {
	siz[u] = 1;
	dep[u] = dep[from] + 1;
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from) continue;
		dfs(to, u);
		siz[u] += siz[to];
		if (!son[u] || siz[to] > siz[son[u]]) son[u] = to;
	}
}
void calc_ask(int u, int from, int rt) {
	int f = k + 2*dep[rt]-dep[u];
	if (f >= 1)c += sum[f] + a[u]*num[f];
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || vis[to]) continue;
		calc_ask(to, u, rt);
	}
}
void calc(int u, int from, int val) {
  sum[dep[u]]+=val*a[u];
  num[dep[u]]+=val;
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || vis[to]) continue;
		calc(to, u, val);
	}

}
void dfs2(int u, int from, int keep) {
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || to == son[u]) continue;
		dfs2(to, u, 0);
	}
	if (son[u]) dfs2(son[u], u, 1), vis[son[u]] = 1;
	//一条链一条的计算
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || to == son[u]) continue;
		calc_ask(to, u, u);
		calc(to, u, 1);
	}
	ans[u] = c;
	vis[son[u]] = 0;
	c = 0;
	sum[dep[u]] += a[u];
	num[dep[u]] += 1;
	if (!keep) {
		calc(u, from, -1);
	}
}


int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i < n; i++) {
		int x, y;
		cin >> x >> y;
		add(x, y);
		add(y, x);
	}
	dfs(1, 0);
	dfs2(1, 0, 0);
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
~~~



## 树的重心

对于某个点，若删去它后形成的最大的连通块的大小最小，我们称该点为树的重心

## 点分治

在一个树上，对具有某些限定条件的路径静态地进行统计地算法

做法

①找到当前树的重心，以重心为根节点

②处理经过根节点的所有路径

③删掉根节点

④对于所有生成的子树，重复以上步骤

dis[u, v] = dis[u, rt] + dis[rt, v]



~~~C++
//求树上小于等于k的路径
//注意 一定要逐个清除贡献  每个贡献要开int来记录
int n, m, rt, mxp[maxn], sum;
int head[maxn], mm;
int tmp[maxn], siz[maxn], dis[maxn], ans; //tmp记录距离  siz子树大小 dis根到点的距离
bool vis[maxn]; //jud判断与之前子树距离i是否存在, ans记录答案  vis记录被删除的点
int a[(int)1e7+10];
int lowbit(int x) { return x & -x; }
void add(int x, int w) {
	x++;
	for (int i = x; i <= 10000000; i += lowbit(i)) a[i] += w;
}
int query(int x) {
	int res = 0;
	x++;
	for (int i = x; i; i -= lowbit(i)) res += a[i];
	return res;
}
struct Edge {
	int to, nxt, w;
}edge[maxn << 1];
void add(int x, int y, int w) {
	edge[++mm] = { y,head[x],w };
	head[x] = mm;
}
//找重心 并且处理以它为子树节点个数
void getrt(int u, int from) {
	siz[u] = 1; mxp[u] = 0;  //初始化
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || vis[to]) continue;
		getrt(to, u);
		siz[u] += siz[to];
		mxp[u] = max(mxp[u], siz[to]); //更新最大子节点
	}
	mxp[u] = max(mxp[u], sum - siz[u]);  //考虑u的祖先节点  等价
	if (mxp[u] < mxp[rt]) rt = u;   //更新重心
}
void getdis(int u, int from) {
	tmp[++tmp[0]] = dis[u];    //存储距离
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (to == from || vis[to])  continue;
		dis[to] = dis[u] + edge[i].w;
		getdis(to, u);
	}
}

void calc(int u) {
	vector<int>v;
	add(0,1);
	v.push_back(0);
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (vis[to]) continue;
		tmp[0] = 0;            //个数置零
		dis[to] = edge[i].w;
		getdis(to, u);     //处理距离
		//先搞完一个分支 然后在加进去
		for (int j = 1; j <= tmp[0]; j++) {
			if (m >= tmp[j])
                //自己操作
				ans += query(m - tmp[j]);
		}
		for (int j = 1; j <= tmp[0]; j++) 
            //自己操作
            add(tmp[j], 1), v.pb(tmp[j]);
	}
    //自己操作
	for (auto i : v) add(i, -1); 
}
void solve(int u) {
	vis[u] = 1;    //删点
	calc(u);
	for (int i = head[u]; i; i = edge[i].nxt) {
		int to = edge[i].to;
		if (vis[to])  continue;
		sum = siz[to], mxp[rt = 0] = 0x3f3f3f3f;
		getrt(to, 0);
		getrt(rt, 0);
		solve(rt);
	}
}
signed main() {
	while (cin >> n >> m, n || m) {
		for (int i = 1; i <= n; i++) head[i] = dis[i]= vis[i]=0;
		mm = ans = rt = 0;
		for (int i = 1; i < n; i++) {
			int x, y, w;
			cin >> x >> y >> w;
			x++, y++;
			add(x, y, w);
			add(y, x, w);
		}
		mxp[0] = sum = n;// 一开始rt=0  节点个个数为n
		getrt(1, 0);   //此时siz数组存放的是以1为根的子树距离
		getrt(rt, 0);
		solve(rt);   //分治
		cout << ans << '\n';
	}
}
~~~

## 2-sat

题目：每件事必须做，每件事有两个点，每件事选一个点来做

 2-SAT，简单的说就是给出 n 个集合，每个集合有两个元素，已知若干个 <a,b> ，表示 a 与 b 矛盾（其中 a 与 b 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 n 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。 

建图：a1和b2有矛盾，a1和b1建边  a2和b1建边   

 输出方案时可以通过变量在图中的拓扑序确定该变量的取值。如果变量 ¬x的拓扑序在 x 之后，那么取 x 值为真。应用到 Tarjan 算法的缩点，即 x 所在 SCC 编号在 ¬x 之前时，取 x 为真。因为 Tarjan 算法求强连通分量时使用了栈，所以 Tarjan 求得的 SCC 编号相当于反拓扑序。 

如何合法则每对点的id[]不同

~~~c++
const int maxn = 2010;
const int maxm = 4000010;
int n,m,head[maxn],mm;
struct Edge{
    int to,nxt;
}edge[maxm];
int dfn[maxn],low[maxn],tim;
int stk[maxn],ss;
bool vis[maxn];
int id[maxn],cnt;
void add(int x,int y){ edge[++mm]={y,head[x]};head[x]=mm;}
void tarjan(int u){
    dfn[u]=low[u]=++tim;
    stk[++ss]=u,vis[u]=1;
    for(int i=head[u];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(!dfn[to]){
            tarjan(to);
            low[u]=min(low[u],low[to]);
        }
        else if (vis[to]) low[u]=min(low[u],dfn[to]);
    }
    if(dfn[u]==low[u]){
        int y;
        ++cnt;
        do{
           y=stk[ss--];
           vis[y]=0;
           id[y]=cnt;
        }while(y!=u);
    }
}
bool ck(){
    for(int i=0;i<2*n;i++){
        if(!dfn[i]) tarjan(i);
    }
    for(int i=0;i<2*n;i+=2){
        if(id[i]==id[i+1]) return 0;
    }
    return 1;
}
void init(){
    for(int i=0;i<2*n;i++) dfn[i]=head[i]=vis[i]=id[i]=low[i]=0;
    mm=0;
    ss=0;
    tim=0;
}
int main(){
    while(cin>>n>>m){
    init();
    for(int i=1;i<=m;i++){
        int a1,a2,b1,b2;
        scanf("%d%d%d%d",&a1,&a2,&b1,&b2);
        add(2*a1+b1,2*a2+1-b2);
        add(2*a2+b2,2*a1+1-b1);
    }
    if(ck()) printf("YES\n");
    else printf("NO\n");
    }
}
​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//输出字典序最小的方案
vector<int>v;
int sel[maxn]; //sel[]==1 就是被选择的数
bool dfs(int x){
    if(sel[x^1]) return 0;
    v.push_back(x);
    sel[x]=1;
    for(int i=head[x];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(sel[to]) continue;
        if(!dfs(to)) return 0;  //必须选的选不了返回0
    }
    return 1;
}
//输出字典序最小的方案
void solve(){
    for(int i=0;i<2*n;i++){
        //两个人都没有被选
        if(!sel[i]&&!sel[i^1]){ //注意一定要^1
            if(dfs(i)){
                v.clear();
            }
            else{
                for(auto i:v) sel[i]=0;
                v.clear();
            }
        }
    }
    for(int i=0;i<2*n;i++) if(sel[i]) cout<<i<<'\n';
}
​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
随便输出方案
//取小的输出
void solve(){
    for(int i=0;i<2*n;i+=2){
        if(id[i]<id[i+1]) cout<<i<<'\n';
        else cout<<i+1<<'\n';
    }
}
~~~



